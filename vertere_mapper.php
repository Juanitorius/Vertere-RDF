#!/usr/bin/env php
<?php
ini_set('memory_limit', '2048M');
define('LIB_DIR', dirname(__FILE__) . '/lib/');
define('MORIARTY_DIR', LIB_DIR.'moriarty/');
define('MORIARTY_ARC_DIR', LIB_DIR.'arc/');
include_once MORIARTY_DIR.'moriarty.inc.php';
include_once MORIARTY_DIR.'simplegraph.class.php';
include_once 'inc/sequencegraph.class.php';
include_once 'inc/csvreader.class.php';
include_once 'inc/vertere.class.php';
include_once 'inc/diagnostics.php';

define('NS_CONV', 'http://example.com/schema/data_conversion#');
define('NS_RDF', 'http://www.w3.org/1999/02/22-rdf-syntax-ns#');

$spec_file = file_get_contents('inc/spec.ttl');
$spec = new SimpleGraph();
$spec->from_turtle($spec_file);

$specs = $spec->get_subjects_of_type(NS_CONV.'Spec');
if (count($specs) > 1) { abort('spec file may only contain one conversion spec'); }
$spec_uri = $specs[0];

//Find format and create reader for it
$format_uri = $spec->get_first_resource($spec_uri, NS_CONV.'format');
$reader = $format_uri == NS_CONV.'CSV' ? new CsvReader(STDIN) : null;
if ($reader == null) { abort("Format ${format_uri} is not supported."); }

//Find uri specs
$uri_spec_seq = $spec->get_first_resource($spec_uri, NS_CONV.'uri_specs');
if (empty($uri_spec_seq)) { abort('Unable to find any sequence of uris to create'); }
$uri_specs = $spec->get_sequence_values($uri_spec_seq);
if (empty($uri_specs)) { abort('Unable to find any sequence of uris to create'); }

//Find statement specs
$statement_spec_seq = $spec->get_first_resource($spec_uri, NS_CONV.'statement_specs');
if (empty($statement_spec_seq)) { abort('Unable to find any sequence of statements to create'); }
$statement_specs = $spec->get_sequence_values($statement_spec_seq);
if (empty($statement_specs)) { abort('Unable to find any sequence of statements to create'); }

//Make lookups quicker by banging them into a PHP array
$lookups = array();
$lookup_uris = $spec->get_subjects_of_type(NS_CONV.'Lookup');
foreach ($lookup_uris as $lookup) {
	$entries = $spec->get_subject_property_values($lookup, NS_CONV.'lookup_entry');
	foreach ($entries as $entry) {
		$lookup_key = $spec->get_first_literal($entry['value'], NS_CONV.'lookup_key');
		if (isset($lookups[$lookup][$lookup_key])) { abort("Lookup <${lookup}> contained a duplicate key"); }
		$lookup_values = $spec->get_subject_property_values($entry['value'], NS_CONV.'lookup_value');
		if (count($lookup_values) > 1) { abort("Lookup ${lookup} has an entry ${entry['value']} that has more than one lookup value assigned."); }
		$lookups[$lookup][$lookup_key] = $lookup_values[0];
	}
}
$base_uri = $spec->get_first_literal($spec_uri, NS_CONV.'base_uri');

$output_graph = new SimpleGraph();

//Read off header rows
$header_rows = $spec->get_first_literal($spec_uri, NS_CONV.'header_rows');
for ($i = 0; $i < $header_rows; $i++) { $reader->next_record(); }
//Create graph from records
while ($record = $reader->next_record()) {
	$uris = array();
	//Create our URIs and keep them for the property processing
	foreach ( $uri_specs as $uri_spec ) {
		$source_column = $spec->get_first_literal($uri_spec, NS_CONV.'source_column');
		$source_column--; //make the source column zero-indexed
		$column_value = $record[$source_column];
		if (empty($column_value)) { continue; }
		$column_is_uri = $spec->get_first_literal($uri_spec, NS_CONV.'column_is_uri');
		$preg_pattern = $spec->get_first_literal($uri_spec, NS_CONV.'preg_pattern');
		$preg_replace = $spec->get_first_literal($uri_spec, NS_CONV.'preg_replace');
		if ($preg_pattern && $preg_replace) {
			$column_value = preg_replace("%${preg_pattern}%", "${preg_replace}", $column_value);
		}

		if ($column_is_uri) {
			$uri = $column_value;
		} else if ($spec->has_resource_triple($uri_spec, NS_RDF.'type', NS_CONV.'UriLookupSpec')) {
			$lookup = $spec->get_first_resource($uri_spec, NS_CONV.'lookup');
			if (!isset($lookups[$lookup][$column_value])) { abort("Lookup ${lookup} did not contain a lookup for ${record[$source_column]}"); }
			$lookup_value = $lookups[$lookup][$column_value];
			if ($lookup_value['type'] != 'uri') { abort("${lookup} contained values that were not URIs but is used as a URI lookup."); }
			$uri = $lookup_value['value'];
		} else {
			//Gather URI parts
			$container = $spec->get_first_literal($uri_spec, NS_CONV.'container');
			$urlify = $spec->get_first_literal($uri_spec, NS_CONV.'urlify');
			$base_uri_override = $spec->get_first_literal($uri_spec, NS_CONV.'base_uri');
			$base_uri_from = $spec->get_first_resource($uri_spec, NS_CONV.'base_uri_from');
			if ($base_uri_from && !isset($uris[$base_uri_from])) { abort("${spec_uri} wishes to use the uri generated by ${base_uri_from} but this has not been created yet"); }
			
			$append_uri = $spec->get_first_literal($uri_spec, NS_CONV.'append_uri');
			$base_to_use = $base_uri_override ? $base_uri_override : $base_uri;
			$base_to_use = $base_uri_from ? $uris[$base_uri_from] : $base_to_use;
			$uri_part = $urlify == "true" ? Vertere::urlify($column_value) : $column_value;
			//Check base uri finishes with a slash or a hash
			if (!preg_match('%[/#]$%', $base_to_use)) { $base_to_use .= '/'; }
			//Compose URI
			$uri = $container ? "${base_to_use}${container}/${uri_part}${append_uri}" : "${base_to_use}${uri_part}${append_uri}";
		}
		$type = $spec->get_first_resource($uri_spec, NS_CONV.'type');
		if ($type) {
			$output_graph->add_resource_triple($uri, NS_RDF.'type', $type);
		}
		$uris[$uri_spec] = $uri;
	}
	
	//Create our statements from the statement specs
	foreach ( $statement_specs as $statement_spec ) {
		$subject_from = $spec->get_first_resource($statement_spec, NS_CONV.'subject_from');
		if (!isset($uris[$subject_from])) { continue; } //If no subject, then can't make statement
		$subject = $uris[$subject_from];
		$property = $spec->get_first_resource($statement_spec, NS_CONV.'property');
		if (empty($property)) { abort("${statement_spec} does not contain a property."); }
		$source_column = $spec->get_first_literal($statement_spec, NS_CONV.'source_column');
		$source_column_seq = $spec->get_first_resource($statement_spec, NS_CONV.'source_columns');
		$object_from = $spec->get_first_resource($statement_spec, NS_CONV.'object_from');
		$language = $spec->get_first_literal($statement_spec, NS_CONV.'language');
		$datatype = $spec->get_first_resource($statement_spec, NS_CONV.'datatype');
		if ($spec->has_resource_triple($statement_spec, NS_RDF.'type', NS_CONV.'StatementLookupSpec')) {
			$source_column--; //make the source column zero-indexed
			$lookup = $spec->get_first_resource($statement_spec, NS_CONV.'lookup');
			if (!isset($lookups[$lookup][$record[$source_column]])) { abort("Lookup ${lookup} did not contain a lookup for ${record[$source_column]}"); }
			$lookup_value = $lookups[$lookup][$record[$source_column]];
			if ($lookup_value['type'] == 'uri') {
				$output_graph->add_resource_triple($subject, $property, $lookup_value['value']);
			} else {
				$output_graph->add_literal_triple($subject, $property, $lookup_value['value'], @$lookup_value['lang'], @$lookup_value['datatype']);
			}
		} else if ($source_column) {
			$source_column--; //make the source column zero-indexed
			$value = $record[$source_column];
			$output_graph->add_literal_triple($subject, $property, $value, $language, $datatype);
		} else if ($source_column_seq) {
			$source_columns = $spec->get_sequence_values($source_column_seq);
			$values = array();
			foreach($source_columns as $source_column) {
				$values[] = $record[$source_column - 1];
			}
			$glue = $spec->get_first_literal($statement_spec, NS_CONV.'source_column_glue');
			$value = implode($glue, $values);
			$output_graph->add_literal_triple($subject, $property, $value, $language, $datatype);
		} else if ($object_from) {
			if (!isset($uris[$object_from])) { continue; } //If no object then can't make statement
			$object = $uris[$object_from];
			$output_graph->add_resource_triple($subject, $property, $object);
		} else {
			abort("$statement_spec does not specify source column(s) or object uri");
		}
		//if (!empty($datatype)) { Vertere::validate_for_datatype(); }
		
	}
	echo $output_graph->to_ntriples();
	$output_graph->remove_all_triples();
}